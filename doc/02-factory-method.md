# 工厂方法模式

- [模式介绍](#模式介绍)
- [优点](#优点)
- [缺点](#缺点)
- [适用范围](#适用范围)

## 模式介绍

定义一个创建对象的接口，定义所有标准通用行为，将创建细节放到子类中实现（让子类决定哪个类实例化）并输出给客户端。
解决了简单工厂模式中的封闭开放原则问题。
不适合使用工厂方法的情况：
    实例化的类永远不会改变；或者实例化发生在子类可以轻易覆盖的操作中（比如初始化）。
    
    抽象工厂：FactoryMethod
    子工厂： CarFactory, BicycleFactory
    抽象产品设计： VehicleInterface
    产品线： PublicBicycle, RacingBicycle, Bus, RacingCar

工厂方法（FactoryMethod）规定了子工厂必须有生产车辆的功能（`abstract protected function createVehicle($type);`），
并为子工厂提供`create($type, $speed = 100)`通用行为。

VehicleInterface规定生产的产品必须设置最大时速（setMaxSpeed）和读取最大时速（getMaxSpeed）。

至于如何生产产品，客户不需要关心，只需要联系具体工厂（`比如需要汽车则 new CarFactory`），并告知生产是公共汽车还是跑车
（`CarFactory::create(2, 100)`），拿到需要的产品后，就可以设置速度和读取最大速度了。

现在有CarFactory, BicycleFactory两个工厂，四种产品。当新增一种产品的时候，则新增一个子工厂并确定如何生产产品（创建对象），
当然产品需要符合抽象产品设计（即创建的产品类需要实现VehicleInterface接口），这时客户就可以通过这个工厂获取产品了。

## 优点
工厂方法针对每一种产品提供一个工厂类，通过不同的工厂实例来创建不同的产品实例，在同一等级结构中，支持增加任意产品。
可以使用户根据参数获得对应的类实例，避免了直接实例化类，降低了耦合性；
符合开闭原则的——对扩展开放、对修改关闭。

## 缺点


## 适用范围
当一个类不知道它所必须创建对象的类或一个类希望由子类来指定它所创建的对象时，当类将创建对象的职责委托给多个帮助子类中得某一个，
并且你希望将哪一个帮助子类是代理者这一信息局部化的时候，可以使用工厂方法模式。
